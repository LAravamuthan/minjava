
	public static List<Integer> GetSubtreeNodes(int[][] ad, int node, String[] tagnames)
	{
		Queue<Integer> q = new LinkedList<>();
		q.add(node);
		List<Integer> common = new ArrayList<Integer>();

		while(q.isEmpty() == false){
			int root = q.peek();					//get the element at the front.
			System.out.println("root = " + root);
			q.remove();								//remove the element.
			common.add(root);
			for(int i = 0 ; i < ad[root].length ; i++)		//check all the elements.
				if(ad[root][i] == 1) {
					q.add(i);
				}
		}

		return common;
	}

//Function to get the common fields between the two tables, which would be joined to get final result.
	public static int[] GetCommonFields(int[][] ad1, int[][] ad2,int node1, int node2, String[] tagnames1, String[] tagnames2)
	{
		List<Integer> fields1, fields2;

		fields1 = GetSubtreeNodes(ad1,node1,tagnames1);

		System.out.println("The list of fields for table 1 is: ");
		for(int i = 0 ; i < fields1.size() ; i++)
			System.out.print(fields1.get(i) + " ");

		fields2 = GetSubtreeNodes(ad2,node2,tagnames2);
		System.out.println();

		System.out.println("The list of fields for table 2 is: ");
		for(int i = 0 ; i < fields2.size() ; i++)
			System.out.print(fields2.get(i) + " ");

		int[] joinfields = new int[tagnames1.length];
		for(int i = 0 ; i < joinfields.length  ; i++)
			joinfields[i] = -1;

		//Add tagnames for all nodes from first table
		for(int i = 0 ; i < fields1.size() ; i++)
			for(int j = 0 ; j < fields2.size() ; j++) {
				int index1 = fields1.get(i);
				int index2 = fields2.get(j);
				if (tagnames1[index1].equalsIgnoreCase(tagnames2[index2]))
					joinfields[index1] = index2;
			}

		System.out.println();
			System.out.println("Now printing the joining fields : ");
			for(int i = 0 ; i < joinfields.length ; i++)
				if(joinfields[i] != -1)
					System.out.println("First node : " + i + " second node : " + joinfields[i]);

		return joinfields;
	}

	/Conditional expression generated from multiple fields.
    	public CondExpr[] GenerateCondExprMultiple(List<Integer> fldtrk1, List<Integer> fldtrk2, int[] joinfield, boolean ContainOrEquality)
    	{
    		int n = joinfield.length;
    		CondExpr[] outFilter  = new CondExpr[n];
    		for(int i = 0 ; i < n ; i++)
    			outFilter[i] = null;

    		System.out.println("In generate conditional expression multiple");
    		int count = 0;


    		for(int i = 0 ; i < n ; i++) {
    			if (joinfield[i] == -1)
    				continue;

    			int pos1 = 3*fldtrk1.get(i)+3;					//get first column index
    			int pos2 = 3*fldtrk2.get(joinfield[i])+3;		//get second column index
    			System.out.println("i = " +  i + " joinfields[i] = " + joinfield[i]);
    			outFilter[count] = new CondExpr();
    			outFilter[count].next = null;
    			if (ContainOrEquality) {
    				outFilter[count].op = new AttrOperator(AttrOperator.aopLT);            //if you need to check containment
    			} else {
    				outFilter[count].flag = 0;
    				outFilter[count].op = new AttrOperator(AttrOperator.aopEQ);        //if you need to check equality
    			}

    			outFilter[count].type1 = new AttrType(AttrType.attrSymbol);
    			outFilter[count].type2 = new AttrType(AttrType.attrSymbol);
    			outFilter[count].operand1.symbol = new FldSpec(new RelSpec(RelSpec.outer), pos1);
    			outFilter[count].operand2.symbol = new FldSpec(new RelSpec(RelSpec.innerRel), pos2);
    			count++;
    		}
    		return outFilter;
    	}

    	public NodeContext JoinTwoFieldsMultiple(TagparamField tag1, TagparamField tag2, int[] joinfieldno, List<Integer> ltfieldtoomit, boolean parentchildflag, boolean ContainOrEquality)
        	{

        		AttrType [] tagattrtype1  = tag1.GetTagParams().getTupleAtrTypes();
        		short    [] tagattrsize1  = tag1.GetTagParams().getTupleStringSizes();
        		int      tagtupsize1      = tag1.GetTagParams().getNodeSizeofTuple();
        		String   taghpfilename1   = tag1.GetTagParams().getNodeHeapFileName();
        		int      outer            = tagattrtype1.length;

        		AttrType [] tagattrtype2  = tag2.GetTagParams().getTupleAtrTypes();
        		short    [] tagattrsize2  = tag2.GetTagParams().getTupleStringSizes();
        		int      tagtupsize2      = tag2.GetTagParams().getNodeSizeofTuple();
        		String   taghpfilename2   = tag1.GetTagParams().getNodeHeapFileName();
        		int      inner            = tagattrtype2.length;


        		System.out.println("Tag1 attribute types ");
        		for(int  i = 0 ; i < tagattrtype1.length ; i++)
        			System.out.printf(tagattrtype1[i].toString() + " ");         //what kind of fields are present in both tables?
        		System.out.println("Tag2 attribute types ");
        		for(int  i = 0 ; i < tagattrtype2.length ; i++)
        			System.out.println(tagattrtype2[i].toString() + " ");         //what kind of fields are present in both tables?


        		AttrType[] JoinedTagAttrtype = null;
        		short [] JoinedTagsize = null;
        		int JoinedTagTupSize = 0;

        		byte[] array = new byte[10];
        		new Random().nextBytes(array);

        		String JoinedTaghpfilename = joinfile+filecount;//new String(array, Charset.forName("UTF-8"));
        		Heapfile JoinedTaghpfile = null;
        		System.out.println("Heapfile being constructed : " + JoinedTaghpfilename);


        		System.out.println("Heap file address for tag1 : " + tag1.GetTagParams().getNodeHeapFile());
        		ScanHeapFile(tag1.GetTagParams(),true);
        		ScanHeapFile(tag2.GetTagParams(),true);

        		try
        		{
        			JoinedTaghpfile = new Heapfile(JoinedTaghpfilename);
        		}
        		catch (Exception e)
        		{
        			System.err.println("*** error in Heapfile constructor ***");
        			e.printStackTrace();
        		}

        		RID JoinedTagRID = new RID();

        		FldSpec[] projlist_tag1 = null, projlist_tag2  = null;
        		List<Integer> ftoO1 = new ArrayList<Integer>();
        		List<Integer> ftoO2 = ltfieldtoomit;
        		System.out.println("outer = " + outer + " inner = " + inner);     //inner = 3*3 = 9.
        		projlist_tag1 = GetProjections(outer, 0, ftoO1);			//generate projections for the left table

        		//	System.out.println("Proj list tag 1 : ");
        		//	for(int i = 0 ; i < projlist_tag1.length ; i++)
        		//		System.out.println("relation : "+ projlist_tag1[i].relation + " offset : " + projlist_tag1[i].offset);
        		projlist_tag2 = GetProjections(outer, inner, ftoO2);		//generate projections for the right table

        //		System.out.println("Proj list tag 2 : ");
        //		for(int i = 0 ; i < projlist_tag2.length ; i++)
        //			System.out.println("relation : "+ projlist_tag2[i].relation + " offset : " + projlist_tag2[i].offset);

        		/*
        		for(int i=0;i<projlist_tag2.length;i++)
        		{
        			System.out.println(projlist_tag2[i].offset);
        		}*/

        		CondExpr[] outFilter = null;
        		outFilter = GenerateCondExprMultiple(tag1.GetFldtrk(),tag2.GetFldtrk(),joinfieldno, ContainOrEquality);	//generate condexpr for the two joining fields
        		JoinedTagAttrtype = JoinAttrtype(tagattrtype1, tagattrtype2, outer, projlist_tag2);
        		JoinedTagsize     = JoinAttrsize(tagattrsize1, tagattrsize2, ltfieldtoomit);
        		JoinedTagTupSize  = JoinedTupSize(JoinedTagAttrtype, JoinedTagsize);
        	/*
        		System.out.println("jere");
        		System.out.printf("%s %s\n", joinfieldno1, joinfieldno2);
        	for(int i=0;i<JoinedTagsize.length;i++)
        		{
        			System.out.println(JoinedTagsize[i]);
        		}


        		for(int i=0;i<JoinedTagAttrtype.length;i++)
        		{
        			System.out.println(JoinedTagAttrtype[i].toString());
        		}*/

        		FileScan fscan = null;
        		try
        		{
        			fscan = new FileScan(taghpfilename1, tagattrtype1, tagattrsize1, (short) outer, outer, projlist_tag1, null);  //file scan pointer
        		}
        		catch (Exception e)
        		{
        			System.err.println (""+e);
        			e.printStackTrace();
        		}

        		NestedLoopsJoins nlj = null;
        		try
        		{
        			//initalizing nested loop join consructor
        			nlj = new NestedLoopsJoins(tagattrtype1, outer, tagattrsize1, tagattrtype2, inner, tagattrsize2, 10, fscan, taghpfilename2, outFilter, null, projlist_tag2, outer+inner-(3*ltfieldtoomit.size()));
        		}
        		catch (Exception e)
        		{
        			System.err.println ("*** Error preparing for nested_loop_join");
        			System.err.println (""+e);
        			e.printStackTrace();
        			Runtime.getRuntime().exit(1);
        		}

        		Tuple temptup;
        		int parent;
        		IntervalType intval;
        		try
        		{
        			while ((temptup=nlj.get_next()) !=null)
        			{
        				if(parentchildflag)
        				{
        					if(temptup.getIntervalFld(2).getS() == temptup.getIntFld(4))
        					{
        						JoinedTagRID = JoinedTaghpfile.insertRecord(temptup.returnTupleByteArray());	//insert the joined record into a new heap file
        					}
        				}
        				else
        				{
        					JoinedTagRID = JoinedTaghpfile.insertRecord(temptup.returnTupleByteArray());  //get the tag RID of the resulting tuple
        				}
        			}
        		}
        		catch (Exception e)
        		{
        			System.err.println ("*** Error preparing for get_next tuple");
        			e.printStackTrace();
        			Runtime.getRuntime().exit(1);
        		}

        		filecount++;
        		return new NodeContext(JoinedTaghpfile, JoinedTagRID, JoinedTaghpfilename, JoinedTagAttrtype, JoinedTagsize, JoinedTagTupSize);
        	}

        	TagparamField JoinTwoHeapFiles(TagparamField tagpar1, TagparamField tagpar2, List<Integer> ltfieldtoomit, int ftfld, int scfld)
            	{
            		List<Integer> fieldtracker1 = tagpar1.GetFldtrk();
            		List<Integer> fieldtracker2 = tagpar2.GetFldtrk();
            		NodeContext context1 = tagpar1.GetTagParams();
            		NodeContext context2 = tagpar2.GetTagParams();

            		//get on which fields to join the two tables
            		System.out.println("Now joining the two input tables...");
            		GetOmitList(fieldtracker1,fieldtracker2,ltfieldtoomit);
            //		int[] fields = GetFieldsToJoinFromTables(fieldtracker1, fieldtracker2, ftfld, scfld); //get which fields need to be joined

            		int[] fields = new int[2];
            		fields[0] = 3*ftfld+3;				//when we are joining two different heap files, we are doing it on string field and not interval field!
            		fields[1] = 3*scfld+3;

            		System.out.println("The fields to be joined are field[1] = " + fields[0] + " field[2] = " + fields[1]);

            		//Build field tracker for the result table.
            		List<Integer> fieldtracker = new ArrayList<Integer>();

            		for(int i = 0 ; i < fieldtracker1.size() ; i++)
            			fieldtracker.add(fieldtracker1.get(i));

            		for(int i = 0 ; i < fieldtracker2.size() ; i++)         //if a field from second field tracker does not exist in the omit list, add it to the schema.
            			if(ltfieldtoomit.indexOf(fieldtracker2.get(i)+1) == -1)	//NOTE THAT FIELD TRACKER IS 1 INDEXED. SO WE WILL CHECK fieldtracker.get(i)+1
            				fieldtracker.add(fieldtracker2.get(i));

            		System.out.println("Printing out the field tracker from JoinTwoHeapFiles");
            		for(int i = 0 ; i < fieldtracker.size() ; i++)
            			System.out.print(fieldtracker.get(i) + " ");
            		System.out.println();

            		//get which fields are to be removed from second table
            		NodeContext ResultTagPar = null;
            		ResultTagPar = JoinTwoFields(context1, fields[0], context2, fields[1], ltfieldtoomit, false, false);
            		System.out.println("Heapfile for ResultTagPar : " + ResultTagPar.getNodeHeapFileName() + " created ");
            		return new TagparamField(ResultTagPar,fieldtracker);
            	}

            		//New function added which can take in two arbitrary tables, and their field tracers and get what interval fields to join on.
                	public int[] GetFieldsToJoinFromTables(List<Integer> fieldtracker1, List<Integer> fieldtracker2, int ftfld, int scfld)
                	{
                		int[] fields = new int[2];
                		int intervalindex1 = fieldtracker1.indexOf(ftfld);
                		int intervalindex2 = fieldtracker2.indexOf(scfld);
                		fields[0] = 3*intervalindex1+2;
                		fields[1] = 3*intervalindex2+2;
                		return fields;
                	}



